@model RouteGeneratorViewModel
@{
    ViewData["Title"] = "Utilities - Route Generator";
}

<link rel="stylesheet" href="~/lib/leaflet/leaflet.css" />
<link rel="stylesheet" href="~/lib/leaflet-draw/leaflet.draw.css" />
<link rel="stylesheet" href="~/lib/easy-button/easy-button.css" />

<h1>Utilities</h1>

<p>@Html.ValidationMessage("Utilities", new { @class = "text-danger" })</p>

<h4>Route Generator</h4>

<p>
    Leaflet based map to manually create, automatically generator, or optimize coordinate routes as well as boundary geofences.
</p>

<br />
@Html.DisplayFor(model => model, "Breadcrumbs", new { Controller = "Utilities", ControllerText = "Utilities", CurrentPage = "Route Generator" })

<hr />

<button type="button" class="btn btn-primary btn-sm float-end" data-bs-toggle="modal" data-bs-target="#exportModal">
    Export Geofence
</button>
<br />
<br />

<div id="map" style="height: 600px;"></div>

<div class="modal fade" id="importModal" tabindex="-1" aria-labelledby="importModalLabel" aria-hidden="true">
    <div class="modal-dialog model-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="importModalLabel">Import Geofence</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label class="form-label" for="format-group">
                    Format
                </label>
                <div class="input-group" id="format-group" name="format-group">
                    <div class="form-check form-check-inline float-start">
                        <input class="form-check-input" type="radio" id="import-format" name="import-format" value="json" onchange="importFormatChanged(this);" checked>
                        <label class="form-check-label" for="import-format">
                            GeoJSON
                        </label>
                    </div>
                    <div class="form-check form-check-inline float-end">
                        <input class="form-check-input" type="radio" id="import-format" name="import-format" value="ini" onchange="importFormatChanged(this);">
                        <label class="form-check-label" for="import-format">
                            INI
                        </label>
                    </div>
                </div>
                <br />
                <label class="form-label" for="import-geofence">
                    Geofence
                </label>
                <textarea id="import-geofence" name="import-geofence" class="form-control" rows="15"></textarea>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" onclick="importGeofence();">Import</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="exportModal" tabindex="-1" aria-labelledby="exportModalLabel" aria-hidden="true">
    <div class="modal-dialog model-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="exportModalLabel">Export Geofence</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label class="form-label" for="format-group">
                    Format
                </label>
                <div class="input-group" id="format-group" name="format-group">
                    <div class="form-check form-check-inline float-start">
                        <input class="form-check-input" type="radio" id="export-format" name="export-format" value="json" onchange="exportFormatChanged(this);" checked>
                        <label class="form-check-label" for="export-format">
                            GeoJSON
                        </label>
                    </div>
                    <div class="form-check form-check-inline float-end">
                        <input class="form-check-input" type="radio" id="export-format" name="export-format" value="ini" onchange="exportFormatChanged(this);">
                        <label class="form-check-label" for="export-format">
                            INI
                        </label>
                    </div>
                </div>
                <br />
                <label class="form-label" for="export-geofence">
                    Geofence
                </label>
                <textarea id="export-geofence" name="export-geofence" class="form-control" rows="15" readonly></textarea>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" onclick="exportGeofence();">Copy to Clipboard</button>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}
<script src="~/lib/leaflet/leaflet.js"></script>
<script src="~/lib/leaflet-draw/leaflet.draw.js"></script>
<script src="~/lib/easy-button/easy-button.js"></script>
<script src="~/js/geofence-converters.js"></script>
<script>
    let format = 'json';
    const map = L.map('map').setView([34.01, -117.01], 13);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    const shapeOptions = {
        stroke: true,
        color: '#3388ff',
        weight: 3,
        opacity: 1,
        fill: true,
        fillColor: null,
        fillOpacity: 0.2,
    };

    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
    const drawControl = new L.Control.Draw({
        edit: {
            featureGroup: drawnItems,
        },
        draw: {
            polyline: false,
            polygon: {
                allowIntersection: true,
                showArea: true,
                metric: 'km',
                precision: {
                    km: 2,
                },
                shapeOptions,
            },
            rectangle: {
                showRadius: true,
                metric: true,
                shapeOptions,
            },
            circle: false,
            marker: false,
            circlemarker: false,
        },
    });
    map.addControl(drawControl);

    L.easyButton({
        states: [{
            icon: 'fa-solid fa-file-import',
            title: 'Import geofence',
            onClick: (button, map) => $('#importModal').modal('show'),
        }]
    }).addTo(map);

    L.easyButton({
        states: [{
            icon: 'fa-solid fa-trash-can',
            title: 'Delete all layers',
            onClick: (button, map) => {
                if (window.confirm('Are you sure you want to delete all shapes?')) {
                    drawnItems.clearLayers();
                }
            },
        }]
    }).addTo(map);

    map.on('draw:created', (e) => {
        //console.log('onCreated:', e);
        const layer = e.layer;
        if (drawnItems) {
            drawnItems.addLayer(layer);
        }
    });

    $('#exportModal').on('shown.bs.modal', () => {
        const geofence = drawnItems.toGeoJSON();
        const json = JSON.stringify(geofence, null, 2);
        $('#export-geofence').val(json);
    });

    const importFormatChanged = (e) => format = e.value;

    const importGeofence = () => {
        const geofenceData = $('#import-geofence').val();
        if (!geofenceData) {
            return;
        }
        const geofence = formatGeofenceToGeoJson(format, geofenceData);
        loadGeofence(geofence);

        $('#importModal').modal('hide');
    };

    const exportFormatChanged = (e) => {
        const exportFormat = e.value;
        const geofence = $('#export-geofence').val();

        switch (exportFormat) {
            case 'json':
                // Convert ini to json geofence
                const geojson = iniToGeoJson(geofence);
                const json = JSON.stringify(geojson, null, 2);
                //console.log('json:', json);
                $('#export-geofence').val(json);
                break;
            case 'txt':
            case 'ini':
                // Convert json to ini geofence
                const iniData = [];
                drawnItems.eachLayer(layer => {
                    const geojson = layer.toGeoJSON();
                    const data = geoJsonToIni(geojson);
                    iniData.push(data);
                });
                const ini = iniData.join('');
                //console.log('ini:', ini);
                $('#export-geofence').val(ini);
                break;
        }
    };

    const exportGeofence = () => {
        const geofence = $('#export-geofence').val();
        if (geofence) {
            copyToClipboard(geofence);
        }
    };

    const formatGeofenceToGeoJson = (format, data) => {
        //console.log('format:', format, 'data:', data);
        if (data.length === 0) {
            return null;
        }
        if (typeof data === 'object') {
            return data;
        }
        switch (format) {
            case 'json':
                return JSON.parse(data);
            case 'txt':
            case 'ini':
                return iniToGeoJson(data);
            default:
                throw Error('Unsupported geofence format');
        }
    };

    const loadGeofence = (data) => {
        if (!drawnItems) {
            return;
        }
        const leafletGeoJSON = new L.GeoJSON(data);
        leafletGeoJSON.eachLayer(layer => {
            // TODO: Get area size of geofence
            const html = `
            <b>Name:</b> ${layer.feature.properties.name}<br>
            <b>Area:</b> ${0} km2
`;
            layer.bindTooltip(html);
            drawnItems.addLayer(layer);
        });
    };
</script>
}